import random
from typing import Any, List, Tuple
from xml.etree.cElementTree import ElementTree
from os.path import join
from copy import deepcopy

if __name__ == "__main__":
    from fuzzer import Fuzzer
else:
    from .fuzzer import Fuzzer

import sys
sys.path.append("..")
from mutators import Mutator
from runners import Runner
from loggers import Logger
from utils import Seed
from scheduler import PowerSchedule
from config import MUTATION_COUNT, MAX_DICT, REPLACE_COUNT


class GreyboxFuzzer(Fuzzer):
    def __init__(self,
                 seeds: List[ElementTree],
                 runner: Runner,
                 mutator: Mutator,
                 logger: Logger,
                 schedule: PowerSchedule,
                 verbose: bool,
                 write_path: str) -> None:

        # List of existing seeds
        self.seeds: List[Seed] = list(map(lambda x: Seed(x), seeds))

        self.seed_index: int = 0
        self.population: List[Seed] = []
        self.verbose: bool = verbose
        self.total_coverage = set()

        self.write_path: str = write_path
        self.schedule: PowerSchedule = schedule
        self.runner: Runner = runner
        self.logger: Logger = logger
        self.mutator: Mutator = mutator

        self.log_count = 0

        # Current dictionary over the amount
        self.current_dict: dict = {"SCHEMA": 0, "PASS": 0, "SCHEMATRON": 0, "UNKNOWN": 0, "FAIL": 0, "XML": 0}
        
        self.chosen_seed = None


    def reset(self) -> None:
        """"Reset the initial population, seed index, coverage information"""
        self.coverages_list = []
        self.outcome_list = []
        self.seed_index = 0

    def create_candidate(self) -> ElementTree:
        """Returns an input generated by fuzzing a seed in the population"""
        seed: Seed = self.schedule.choose(self.population)

        # Check if the seed has been used more than the set value for REPLACE_COUNT and
        # remove seed from population if it is not UNKNOWN or FAIL and it is not the only seed of its outcome in the popultaion
        if seed.chosen_count > REPLACE_COUNT and self.current_dict[seed.outcome] != 1 and seed.outcome not in ["UNKNOWN", "FAIL"]:
            self.population.remove(seed)
            # decrease amount of the outcome in current dict
            self.current_dict[seed.outcome] -= 1
        else:
            seed.chosen_count += 1
        self.chosen_seed = seed

        candidate: ElementTree = deepcopy(seed.data)
        num_mutations: int = random.randint(1, MUTATION_COUNT)
        # Apply mutations to the candidate
        for _ in range(num_mutations):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self) -> ElementTree:
        """Returns each seed once and then generates new inputs"""
        inp: ElementTree = None
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.chosen_seed = self.seeds[self.seed_index]
            inp = self.chosen_seed.data
        else:
            # Mutating
            inp = self.create_candidate()
        return inp
    
    def add_to_population(self, result: str, outcome: str, document: ElementTree):
        # Make new seed
        seed: Seed = Seed(document)
        seed.coverage = self.runner.code_coverage
        seed.outcome = outcome
        seed.result = result

        # Administration
        self.population.append(seed)
        self.total_coverage = self.total_coverage.union(self.runner.code_coverage)
        
        seed.population_name = outcome

    def only_log(self, result: str, outcome: str, document: ElementTree):
        # Write and log new file
        filename: str = outcome + "-" + str(self.log_count) + ".xml"
        self.log_count += 1
        document_path: str = join(self.write_path, filename)
        document.write(document_path, encoding="utf-8", xml_declaration=True)
        self.logger.log(filename, result)
    
    def handle_feedback(self, result: str, outcome: str, document: ElementTree):
        # log outcome if it is FAIL or UNKNOWN
        if outcome == "FAIL" or outcome == "UNKNOWN":
            filename: str = outcome + "_" + str(self.seed_index) + ".xml"
            document_path: str = join(self.write_path, filename)
            document.write(document_path, encoding="utf-8", xml_declaration=True)
            self.logger.log(filename, result)
        # if type of outcome is not at its max, add to population
        if self.current_dict[outcome] < MAX_DICT[outcome]:
            self.add_to_population(result, outcome, document)
            self.current_dict[outcome] += 1

        self.seed_index += 1

    def run(self) -> Tuple[str, str]:
        # fuzz it
        document: ElementTree = self.fuzz()
        # Make new name for file
        filename: str = "fuzzed_document_" + str(self.seed_index) + ".xml"
        
        result, outcome: str = self.runner.run(document, filename)
        self.handle_feedback(result, outcome, document)
        return result, outcome 

    def multiple_runs(self, run_count: int, stats: bool) -> List[Tuple[str, str]]:
        results: List[Tuple[str,str]] = []
        code_block_total = 55
        try:
            for i in range(1, run_count + 1):
                result: Tuple[str,str] = self.run()
                results.append[result]
                run_num: int = i
                pop_count: int = sum(self.current_dict.values())
                percent_coverage: float = len(self.total_coverage)/code_block_total * 100
                to_print: str = "Run: " + str(run_num) + " Population count: " + str(pop_count)
                to_print += " Coverage: " + str(format(percent_coverage, '.2f')) + " %"
                if stats:
                    print(to_print,  end='\r')
        except KeyboardInterrupt:
            print("Program terminated manually, writing population, do not stop it")
            # This is just here for catching the exception, it then runs the rest of the code

        
        if self.verbose:
            for cov in self.coverages_list:
                print(cov)
            print(len(self.population))

        # Write the population to fuzzed documents
        for seed in self.population:
            self.only_log(seed.result, seed.outcome, seed.data)

        return [result for result in results if result[1] in "FAIL"]
